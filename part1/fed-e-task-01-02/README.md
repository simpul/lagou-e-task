# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()
```

最后执行的结果打印的是10。因为当循环执行结束之后，i的值为10。此时调用a[6]这个函数时，console.log的变量i通过作用域链找到的是全局对象上的i，因此会打印10。　

　

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```

这里会报错，因为在ES6语法中let声明的变量会被绑定在当前的块级作用域中。当执行if语句中的内容时，它是一个块级作用域，console.log打印的变量tmp会引用当前的块级作用域中的同名变量。由于console语句在let tmp;语句前，也就意味着变量还未声明就进行访问，因此会抛出一个变量未初始化的错误。

　

### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```

Math.min(...arr)

　

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别

var 声明的变量不受块级作用域的影响，声明的变量会进行变量提升（即在声明之前可以访问该变量，访问得到的值为undefined）。同一个变量可以用var声明多次。

let 声明的变量受块级作用域的影响，不会进行变量提升。同一个变量不可以用let声明多次。

const 声明的变量受块级作用域的影响，不会进行变量提升。声明的变量是一个常量，也就是说声明的时候必须赋值，而且之后不能改变它的值。同一个变量不可以用const声明多次。

　

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```

输出20。由于箭头函数根据当前的词法作用域来决定this，因此会继承外层函数调用的this绑定。在这里箭头函数中的this继承了fn函数中的this，由于fn是通过访问obj的属性来调用的，因此fn的this指向的是obj，因此console打印的this.a是obj上的a属性的值。

　

### 6. 简述Symbol类型的用途

避免模块之间造成属性名相同的冲突，可以创建类的私有变量。实现 Symbol.iterator迭代器， 让普通对象变为可迭代对象，供for of循环消费。



### 7. 说说什么是浅拷贝，什么是深拷贝？

浅拷贝和深拷贝这两种说法是针对于引用类型的值来说的。浅拷贝指的是单纯将引用类型的值的内存地址拷贝过来，深拷贝指的是重新创建一个一模一样的对象，新对象跟原对象不共享内存。

　

### 8. 请简述TypeScript与JavaScript之间的关系？

TypeScript是JavaScript的超集（JS有的能力TS都有，除此之外还有JS没有的能力），通过编译器可以将TS编译成JS执行。

　

### 9. 请谈谈你所认为的typescript优缺点

优点：

+ 在编译阶段进行类型检查，能避免一些因为类型错误而在运行阶段导致的报错
+ 跟vs code良好搭配让代码效率有了极大提升



缺点：

+ 掌握TS有一定的学习成本
+ 需要编译成JS才可以执行，集成到构建流程需要额外的开发成本

　

### 10. 描述引用计数的工作原理和优缺点

工作原理：给每一个对象设置一个引用计数器，每当有一个变量引用了这个对象时就将计数器加一。引用失效时计数器就减一。当一个对象的引用计数器为零时,说明此对象没有被引用，就会被当作垃圾进行回收。

优点

+ 发现垃圾时立即回收
+ 最大限度减少程序暂停（时刻监控内存的释放，避免内存占满）

缺点

+ 无法回收循环引用的对象
+ 时间、资源消耗开销大（维护了一个引用计数器，修改的时候需要花时间）

　

### 11. 描述标记整理算法的工作流程

分为：标记阶段、清除阶段、整理阶段三个流程

标记阶段：遍历所有对象找出活动（可达）对象进行标记

清除阶段：遍历所有对象，清除没有标记的对象（同时也会将有标记的对象清除掉标记，方便下一轮的GC操作）

整理阶段：移动未被清除的对象位置（将活动对象放在连续的内存地址上，这样可以避免内存的碎片化）

　

### 12.描述V8中新生代存储区垃圾回收的流程

+ 对象说明：内存空间一分为二，小空间用于存储新生代对象，新生代指的是存活时间较短的对象（例如块级作用域内的变量）

+ 具体过程：

  + 回收过程采用复制算法+标记整理

  + 新生代内存区分为二个等大小空间

  + 使用空间为From，空闲空间为To

  + 活动对象存储于From空间

  + 标记整理后将活动对象拷贝至To

  + From与To交换空间完成释放

+ 回收细节说明：

  + 拷贝过程中可能出现晋升，就是将新生代对象移动至老生代，符合晋升的条件有：
    + 一轮GC还存活的新生代需要晋升
    + To空间的使用率超过25%

　

### 13. 描述增量标记算法在何时使用及工作原理

当新生代晋升且老生代区域内存空间不足的时候就会采用标记整理的方式。

工作原理：垃圾回收与程序执行交替进行，这样可以优化程序的执行效率，不会让垃圾回收操作一直执行阻塞程序执行导致网页应用出现卡顿现象。其中垃圾标记会分多次进行，第一次先遍历全局环境中直接可达的对象，第二次遍历第二层引用的对象。。。依此类推

　